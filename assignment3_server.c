/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "assignment3.h"
#include <string.h>
#include <stdlib.h>
#include <dirent.h>
#include <stdio.h>
#include <unistd.h>
#define READ_MAX_SIZE 512
void merge_1(int a[],int i1,int j1,int i2,int j2);
void mergesort_1(int a[],int i,int j);

char **
function_hostname_1_svc(void *argp, struct svc_req *rqstp)
{
    static char * result;
    static char hostnamefun[1000];
    // to get the host name
    gethostname(hostnamefun, 1000);
    result = hostnamefun;
    return &result;
}
void mergesort_1(int a[],int i,int j)
{
    int divideformid;
    
    if(i<j)
    {
        // initially divideformid is taken to be in the half
        divideformid=(i+j)/2;
        mergesort_1(a,i,divideformid);        //left part is sorted by  recursion
        mergesort_1(a,divideformid+1,j);    //right  half is sorted by recursion
        merge_1(a,i,divideformid,divideformid+1,j);    //merging of two sorted sub-arrays
    }
}
// function for merging the sorted arrays
void merge_1(int a[],int i1,int j1,int i2,int j2)
{
    int temp[50];    //array used for merging
    int i,j,k;
    i=i1;    //beginning of the first list
    j=i2;    //beginning of the second list
    k=0;
    
    while(i<=j1 && j<=j2)    //while elements in both lists
    {
        if(a[i]<a[j])
            temp[k++]=a[i++];
        else
            temp[k++]=a[j++];
    }
    
    while(i<=j1)    //copy remaining elements of the first list
        temp[k++]=a[i++];
    
    while(j<=j2)    //copy remaining elements of the second list
        temp[k++]=a[j++];
    
    //Transfer elements from temp[] back to a[]
    for(i=i1,j=0;i<=j2;i++,j++)
        a[i]=temp[j];
}

mergeOut *
function_mergesort_1_svc(mergeIn *argp, struct svc_req *rqstp)
{
    static mergeOut  result;
    int i;
    int final_size = argp->mergeInput1.mergeInput1_len + argp->mergeInput2.mergeInput2_len;
    result.mergeOutput.mergeOutput_len = final_size;
    result.mergeOutput.mergeOutput_val =  (int*)malloc((final_size)*sizeof(int));
    int *inital = &result.mergeOutput.mergeOutput_val[0];
    int *inital_1 = &argp->mergeInput1.mergeInput1_val[0];
    int *inital_2 = &argp->mergeInput2.mergeInput2_val[0];
    for(i =0;i<argp->mergeInput1.mergeInput1_len;i++)
    {
        *inital = *inital_1;
        inital++;
        inital_1++;
    }
    for(i =0;i<argp->mergeInput2.mergeInput2_len;i++)
    {
        *inital = *inital_2;
        inital++;
        inital_2++;
    }
    mergesort_1(result.mergeOutput.mergeOutput_val,0,final_size-1);
    
    
    return &result;
}

char **
function_encryptedecho_1_svc(char **argp, struct svc_req *rqstp)
{
    static char * result;
    srand((int)time(0));
    result = argp[0];
    for(int i=0;i<strlen(*argp);i++)
    {
        result[i] ^= rand() %254;
    }
    return &result;
}

char **
function_listfiles_1_svc(char **argp, struct svc_req *rqstp)
{
    struct dirent *de;  // Pointer for directory entry
    DIR *dr = opendir(".");
   
    if (dr == NULL)  // opendir returns NULL if couldn't open directory
    {
        printf("Could not open current directory" );
        return 0;
    }
    static char* DirInto;
    DirInto = (char*)malloc((READ_MAX_SIZE + 1)*sizeof(char));
    memset(DirInto, 0, READ_MAX_SIZE + 1);
    
     while ((de = readdir(dr)) != NULL)
    {
        char file1[40];
        strcpy(file1,de->d_name);
        strcat(file1,"\n");
        strcat(DirInto,file1);
        
    }
    closedir(dr);
    return &DirInto;
}

complexNum *
function_addcomplex_1_svc(addComplex *argp, struct svc_req *rqstp)
{
    static complexNum  result;
    result.imaginary = argp->input1.imaginary + argp->input2.imaginary;
    result.real = argp->input1.real + argp->input2.real;
    
    return &result;
}
